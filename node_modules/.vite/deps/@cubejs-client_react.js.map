{
  "version": 3,
  "sources": ["../../@cubejs-client/react/src/CubeContext.js", "../../@cubejs-client/react/src/QueryRenderer.jsx", "../../@cubejs-client/react/src/QueryRendererWithTotals.jsx", "../../@cubejs-client/react/src/utils.js", "../../@cubejs-client/react/src/QueryBuilder.jsx", "../../@cubejs-client/react/src/CubeProvider.jsx", "../../@cubejs-client/react/src/hooks/deep-compare-memoize.js", "../../@cubejs-client/react/src/hooks/is-mounted.js", "../../@cubejs-client/react/src/hooks/cube-fetch.js", "../../@cubejs-client/react/src/hooks/cube-sql.js", "../../@cubejs-client/react/src/hooks/dry-run.js", "../../@cubejs-client/react/src/hooks/lazy-dry-run.js", "../../@cubejs-client/react/src/hooks/cube-query.js", "../../@cubejs-client/react/src/hooks/cube-meta.js"],
  "sourcesContent": ["import { createContext } from 'react';\n\nexport default createContext(null);\n", "import React from 'react';\nimport { equals, toPairs, fromPairs } from 'ramda';\nimport { isQueryPresent } from '@cubejs-client/core';\n\nimport CubeContext from './CubeContext';\n\nexport default class QueryRenderer extends React.Component {\n  static contextType = CubeContext;\n\n  static defaultProps = {\n    cubeApi: null,\n    query: null,\n    render: null,\n    queries: null,\n    loadSql: null,\n    updateOnlyOnStateChange: false,\n    resetResultSetOnChange: true\n  };\n\n  // @deprecated use `isQueryPresent` from `@cubejs-client/core`\n  static isQueryPresent(query) {\n    return isQueryPresent(query);\n  }\n\n  constructor(props) {\n    super(props);\n    this.state = {};\n    this.mutexObj = {};\n  }\n\n  componentDidMount() {\n    const { query, queries } = this.props;\n    if (query) {\n      this.load(query);\n    }\n    if (queries) {\n      this.loadQueries(queries);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const {\n      query, queries, render, cubeApi, loadSql, updateOnlyOnStateChange\n    } = this.props;\n    if (!updateOnlyOnStateChange) {\n      return true;\n    }\n    return !equals(nextProps.query, query)\n      || !equals(nextProps.queries, queries)\n      || ((nextProps.render == null || render == null) && nextProps.render !== render)\n      || nextProps.cubeApi !== cubeApi\n      || nextProps.loadSql !== loadSql\n      || !equals(nextState, this.state)\n      || nextProps.updateOnlyOnStateChange !== updateOnlyOnStateChange;\n  }\n\n  componentDidUpdate(prevProps) {\n    const { query, queries } = this.props;\n    if (!equals(prevProps.query, query)) {\n      this.load(query);\n    }\n\n    if (!equals(prevProps.queries, queries)) {\n      this.loadQueries(queries);\n    }\n  }\n\n  cubeApi() {\n    // eslint-disable-next-line react/destructuring-assignment\n    return this.props.cubeApi || this.context && this.context.cubeApi;\n  }\n\n  load(query) {\n    const { resetResultSetOnChange } = this.props;\n    this.setState({\n      isLoading: true,\n      error: null,\n      sqlQuery: null,\n      ...(resetResultSetOnChange ? { resultSet: null } : {})\n    });\n    const { loadSql } = this.props;\n    const cubeApi = this.cubeApi();\n\n    if (query && isQueryPresent(query)) {\n      if (loadSql === 'only') {\n        cubeApi.sql(query, { mutexObj: this.mutexObj, mutexKey: 'sql' })\n          .then(sqlQuery => this.setState({ sqlQuery, error: null, isLoading: false }))\n          .catch(error => this.setState({\n            ...(resetResultSetOnChange ? { resultSet: null } : {}),\n            error,\n            isLoading: false\n          }));\n      } else if (loadSql) {\n        Promise.all([\n          cubeApi.sql(query, { mutexObj: this.mutexObj, mutexKey: 'sql' }),\n          cubeApi.load(query, { mutexObj: this.mutexObj, mutexKey: 'query' })\n        ]).then(([sqlQuery, resultSet]) => this.setState({\n          sqlQuery, resultSet, error: null, isLoading: false\n        }))\n          .catch(error => this.setState({\n            ...(resetResultSetOnChange ? { resultSet: null } : {}),\n            error,\n            isLoading: false\n          }));\n      } else {\n        cubeApi.load(query, { mutexObj: this.mutexObj, mutexKey: 'query' })\n          .then(resultSet => this.setState({ resultSet, error: null, isLoading: false }))\n          .catch(error => this.setState({\n            ...(resetResultSetOnChange ? { resultSet: null } : {}),\n            error,\n            isLoading: false\n          }));\n      }\n    }\n  }\n\n  loadQueries(queries) {\n    const cubeApi = this.cubeApi();\n    const { resetResultSetOnChange } = this.props;\n    this.setState({\n      isLoading: true,\n      ...(resetResultSetOnChange ? { resultSet: null } : {}),\n      error: null\n    });\n\n    const resultPromises = Promise.all(toPairs(queries).map(\n      ([name, query]) => cubeApi.load(query, { mutexObj: this.mutexObj, mutexKey: name }).then(r => [name, r])\n    ));\n\n    resultPromises\n      .then(resultSet => this.setState({\n        resultSet: fromPairs(resultSet),\n        error: null,\n        isLoading: false\n      }))\n      .catch(error => this.setState({\n        ...(resetResultSetOnChange ? { resultSet: null } : {}),\n        error,\n        isLoading: false\n      }));\n  }\n\n  render() {\n    const {\n      error, queries, resultSet, isLoading, sqlQuery\n    } = this.state;\n    const { render } = this.props;\n\n    const loadState = {\n      error: error ? new Error(error.response?.plainError || error.message || error.toString()) : null,\n      resultSet: queries ? (resultSet || {}) : resultSet,\n      loadingState: { isLoading },\n      sqlQuery\n    };\n\n    if (render) {\n      return render(loadState);\n    }\n\n    return null;\n  }\n}\n", "import React from 'react';\nimport QueryRenderer from './QueryRenderer.jsx';\n\nconst QueryRendererWithTotals = ({ query, ...restProps }) => (\n  <QueryRenderer\n    queries={{\n      totals: {\n        ...query,\n        dimensions: [],\n        timeDimensions: query.timeDimensions\n          ? query.timeDimensions.map(td => ({ ...td, granularity: null }))\n          : undefined\n      },\n      main: query\n    }}\n    {...restProps}\n  />\n);\n\nexport default QueryRendererWithTotals;\n", "export function removeEmpty(obj) {\n  if (Array.isArray(obj) || typeof obj !== 'object') {\n    return obj;\n  }\n\n  return Object.fromEntries(\n    Object.entries(obj)\n      .filter(([, v]) => v != null)\n      .map(([k, v]) => {\n        if (Array.isArray(v)) {\n          return [k, v.map(removeEmpty)];\n        }\n\n        return [k, typeof v === 'object' ? removeEmpty(v) : v];\n      })\n  );\n}\n", "import React from 'react';\nimport { clone, equals, indexBy, pick, prop, uniq, uniqBy } from 'ramda';\nimport {\n  defaultHeuristics,\n  defaultOrder,\n  flattenFilters,\n  getQueryMembers,\n  isQueryPresent,\n  moveItemInArray,\n  movePivotItem,\n  validateQuery,\n  ResultSet,\n  removeEmptyQueryFields\n} from '@cubejs-client/core';\n\nimport QueryRenderer from './QueryRenderer.jsx';\nimport CubeContext from './CubeContext';\nimport { removeEmpty } from './utils';\n\nconst granularities = [\n  { name: undefined, title: 'w/o grouping' },\n  { name: 'second', title: 'Second' },\n  { name: 'minute', title: 'Minute' },\n  { name: 'hour', title: 'Hour' },\n  { name: 'day', title: 'Day' },\n  { name: 'week', title: 'Week' },\n  { name: 'month', title: 'Month' },\n  { name: 'quarter', title: 'Quarter' },\n  { name: 'year', title: 'Year' },\n];\n\nexport default class QueryBuilder extends React.Component {\n  static contextType = CubeContext;\n\n  static defaultProps = {\n    cubeApi: null,\n    stateChangeHeuristics: null,\n    disableHeuristics: false,\n    render: null,\n    wrapWithQueryRenderer: true,\n    defaultChartType: 'line',\n    defaultQuery: {},\n    initialVizState: null,\n    onVizStateChanged: null,\n\n    // deprecated\n    query: null,\n    setQuery: null,\n    vizState: null,\n    setVizState: null,\n  };\n\n  // This is an anti-pattern, only kept for backward compatibility\n  // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state\n  static getDerivedStateFromProps(props, state) {\n    if (props.query || props.vizState) {\n      const nextState = {\n        ...state,\n        ...(props.vizState || {}),\n      };\n\n      if (Array.isArray(props.query)) {\n        throw new Error('Array of queries is not supported.');\n      }\n\n      return {\n        ...nextState,\n        query: {\n          ...nextState.query,\n          ...(props.query || {}),\n        },\n      };\n    }\n    return null;\n  }\n\n  static resolveMember(type, { meta, query }) {\n    if (!meta) {\n      return [];\n    }\n\n    if (Array.isArray(query)) {\n      return query.reduce(\n        (memo, currentQuery) => memo.concat(\n          QueryBuilder.resolveMember(type, {\n            meta,\n            query: currentQuery,\n          })\n        ),\n        []\n      );\n    }\n\n    if (type === 'timeDimensions') {\n      return (query.timeDimensions || []).map((m, index) => ({\n        ...m,\n        dimension: {\n          ...meta.resolveMember(m.dimension, 'dimensions'),\n          granularities,\n        },\n        index,\n      }));\n    }\n\n    return (query[type] || []).map((m, index) => ({\n      index,\n      ...meta.resolveMember(m, type),\n    }));\n  }\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      query: props.defaultQuery || props.query,\n      chartType: props.defaultChartType,\n      validatedQuery: props.query, // deprecated, validatedQuery should not be set until after dry-run for safety\n      missingMembers: [],\n      // todo: rename to `isMetaReady`\n      isFetchingMeta: true,\n      dryRunResponse: null,\n      ...props.vizState, // deprecated\n      ...props.initialVizState,\n    };\n\n    this.mutexObj = {};\n    this.orderMembersOrderKeys = [];\n  }\n\n  async componentDidMount() {\n    this.prevContext = this.context;\n    await this.fetchMeta();\n  }\n\n  async componentDidUpdate(prevProps) {\n    const { schemaVersion, onSchemaChange } = this.props;\n    const { meta } = this.state;\n\n    if (this.prevContext?.cubeApi !== this.context?.cubeApi) {\n      this.prevContext = this.context;\n      await this.fetchMeta();\n    }\n\n    if (prevProps.schemaVersion !== schemaVersion) {\n      try {\n        const newMeta = await this.cubeApi().meta();\n        if (!equals(newMeta, meta) && typeof onSchemaChange === 'function') {\n          onSchemaChange({\n            schemaVersion,\n            refresh: async () => {\n              await this.fetchMeta();\n            },\n          });\n        }\n      } catch (error) {\n        // eslint-disable-next-line\n        this.setState({ metaError: error });\n      }\n    }\n  }\n\n  fetchMeta = async () => {\n    if (!this.cubeApi()) {\n      return;\n    }\n\n    let meta;\n    let metaError = null;\n    let richMetaError = null;\n    let metaErrorStack = null;\n\n    try {\n      this.setState({ isFetchingMeta: true });\n      meta = await this.cubeApi().meta();\n    } catch (error) {\n      metaError = error.response?.plainError || error;\n      richMetaError = error;\n      metaErrorStack = error.response?.stack?.replace(error.message || '', '') || '';\n    }\n\n    this.setState(\n      {\n        meta,\n        metaError: metaError ? new Error(metaError.message || metaError.toString()) : null,\n        richMetaError,\n        metaErrorStack,\n        isFetchingMeta: false,\n      },\n      () => {\n        // Run update query to force viz state update\n        // This will catch any new missing members, and also validate the query against the new meta\n        this.updateQuery({});\n      }\n    );\n  };\n\n  cubeApi() {\n    const { cubeApi } = this.props;\n    // eslint-disable-next-line react/destructuring-assignment\n    return cubeApi || (this.context && this.context.cubeApi);\n  }\n\n  getMissingMembers(query, meta) {\n    if (!meta) {\n      return [];\n    }\n\n    return getQueryMembers(query)\n      .map((member) => {\n        const resolvedMember = meta.resolveMember(member, ['measures', 'dimensions', 'segments']);\n        if (resolvedMember.error) {\n          return member;\n        }\n        return false;\n      })\n      .filter(Boolean);\n  }\n\n  isQueryPresent() {\n    const { query } = this.state;\n    return QueryRenderer.isQueryPresent(query);\n  }\n\n  prepareRenderProps(queryRendererProps) {\n    const getName = (member) => member.name;\n\n    const toTimeDimension = (member) => {\n      const rangeSelection = member.compareDateRange\n        ? { compareDateRange: member.compareDateRange }\n        : { dateRange: member.dateRange };\n\n      return removeEmpty({\n        dimension: member.dimension.name,\n        granularity: member.granularity,\n        ...rangeSelection,\n      });\n    };\n\n    const toFilter = (member) => ({\n      member: member.member?.name || member.dimension?.name,\n      operator: member.operator,\n      ...(['set', 'notSet'].includes(member.operator) ? {} : { values: member.values }),\n    });\n\n    const updateMethods = (memberType, toQuery = getName) => ({\n      add: (member) => {\n        const { query } = this.state;\n        this.updateQuery({\n          [memberType]: (query[memberType] || []).concat(toQuery(member)),\n        });\n      },\n      remove: (member) => {\n        const { query } = this.state;\n\n        return this.updateQuery({\n          [memberType]: (query[memberType] || []).filter((_, index) => index !== member.index),\n        });\n      },\n      update: (member, updateWith) => {\n        const { query } = this.state;\n        const members = (query[memberType] || []).concat([]);\n        members.splice(member.index, 1, toQuery(updateWith));\n        return this.updateQuery({\n          [memberType]: members,\n        });\n      },\n    });\n\n    const {\n      meta,\n      metaError,\n      richMetaError,\n      query,\n      queryError,\n      chartType,\n      pivotConfig,\n      validatedQuery,\n      missingMembers,\n      isFetchingMeta,\n      dryRunResponse,\n      metaErrorStack\n    } = this.state;\n\n    const flatFilters = uniqBy((filter) => `${prop('member', filter)}${prop('operator', filter)}`,\n      flattenFilters((meta && query.filters) || []).map((filter) => ({\n        ...filter,\n        member: filter.member || filter.dimension,\n      })));\n\n    const filters = flatFilters.map((m, i) => ({\n      ...m,\n      dimension: meta.resolveMember(m.member || m.dimension, ['dimensions', 'measures']),\n      operators: meta.filterOperatorsForMember(m.member || m.dimension, ['dimensions', 'measures']),\n      index: i,\n    }));\n\n    const measures = QueryBuilder.resolveMember('measures', this.state);\n    const dimensions = QueryBuilder.resolveMember('dimensions', this.state);\n    const timeDimensions = QueryBuilder.resolveMember('timeDimensions', this.state);\n    const segments = ((meta && query.segments) || []).map((m, i) => ({\n      index: i,\n      ...meta.resolveMember(m, 'segments'),\n    }));\n\n    let availableMeasures = [];\n    let availableDimensions = [];\n    let availableSegments = [];\n    let availableFilterMembers = [];\n\n    const availableMembers = meta?.membersGroupedByCube() || {\n      measures: [],\n      dimensions: [],\n      segments: [],\n      timeDimensions: [],\n    };\n\n    if (meta) {\n      availableMeasures = meta.membersForQuery(query, 'measures');\n      availableDimensions = meta.membersForQuery(query, 'dimensions');\n      availableSegments = meta.membersForQuery(query, 'segments');\n\n      const indexedMeasures = indexBy(prop('cubeName'), availableMembers.measures);\n      const indexedDimensions = indexBy(prop('cubeName'), availableMembers.dimensions);\n      const cubeNames = uniq([...Object.keys(indexedMeasures), ...Object.keys(indexedDimensions)]).sort();\n\n      availableFilterMembers = cubeNames.map((name) => {\n        const cube = indexedMeasures[name] || indexedDimensions[name];\n\n        return {\n          ...cube,\n          members: [\n            ...indexedMeasures[name]?.members,\n            ...indexedDimensions[name]?.members\n          ].sort((a, b) => (a.shortTitle > b.shortTitle ? 1 : -1)),\n        };\n      });\n    }\n\n    const activeOrder = Array.isArray(query.order) ? Object.fromEntries(query.order) : query.order;\n    const members = [\n      ...measures,\n      ...dimensions,\n      ...timeDimensions.map(({ dimension }) => dimension)\n    ];\n\n    let orderMembers = uniqBy(prop('id'), [\n      // uniqBy prefers first, so these will only be added if not already in the query\n      ...members.map(({ name, title }) => ({ id: name, title, order: activeOrder?.[name] || 'none' })),\n    ]);\n\n    if (this.orderMembersOrderKeys.length !== orderMembers.length) {\n      this.orderMembersOrderKeys = orderMembers.map(({ id }) => id);\n    }\n\n    if (this.orderMembersOrderKeys.length) {\n      // Preserve order until the members change or manually re-ordered\n      // This is needed so that when an order member becomes active, it doesn't jump to the top of the list\n      orderMembers = (this.orderMembersOrderKeys || [])\n        .map((id) => orderMembers.find((member) => member.id === id))\n        .filter(Boolean);\n    }\n\n    return {\n      meta,\n      metaError,\n      richMetaError,\n      metaErrorStack,\n      query,\n      error: queryError, // Match same name as QueryRenderer prop\n      validatedQuery,\n      isQueryPresent: this.isQueryPresent(),\n      chartType,\n      measures,\n      dimensions,\n      timeDimensions,\n      segments,\n      filters,\n      orderMembers,\n      availableMeasures,\n      availableDimensions,\n      availableTimeDimensions: availableDimensions.filter((m) => m.type === 'time'),\n      availableSegments,\n      availableMembers,\n      availableFilterMembers,\n      updateQuery: (queryUpdate) => this.updateQuery(queryUpdate),\n      updateMeasures: updateMethods('measures'),\n      updateDimensions: updateMethods('dimensions'),\n      updateSegments: updateMethods('segments'),\n      updateTimeDimensions: updateMethods('timeDimensions', toTimeDimension),\n      updateFilters: updateMethods('filters', toFilter),\n      updateChartType: (newChartType) => this.updateVizState({ chartType: newChartType }),\n      updateOrder: {\n        set: (memberId, newOrder = 'asc') => {\n          this.updateQuery({\n            order: orderMembers\n              .map((orderMember) => ({\n                ...orderMember,\n                order: orderMember.id === memberId ? newOrder : orderMember.order,\n              }))\n              .reduce((acc, { id, order }) => (order !== 'none' ? [...acc, [id, order]] : acc), []),\n          });\n        },\n        update: (order) => {\n          this.updateQuery({\n            order,\n          });\n        },\n        reorder: (sourceIndex, destinationIndex) => {\n          if (sourceIndex == null || destinationIndex == null) {\n            return;\n          }\n\n          const nextArray = moveItemInArray(orderMembers, sourceIndex, destinationIndex);\n          this.orderMembersOrderKeys = nextArray.map(({ id }) => id);\n\n          this.updateQuery({\n            order: nextArray.reduce((acc, { id, order }) => (order !== 'none' ? [...acc, [id, order]] : acc), []),\n          });\n        },\n      },\n      pivotConfig,\n      updatePivotConfig: {\n        moveItem: ({ sourceIndex, destinationIndex, sourceAxis, destinationAxis }) => {\n          this.updateVizState({\n            pivotConfig: movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis),\n          });\n        },\n        update: (config) => {\n          const { limit } = config;\n\n          this.updateVizState({\n            pivotConfig: {\n              ...pivotConfig,\n              ...config,\n            },\n            ...(limit ? { query: { ...query, limit } } : null),\n          });\n        },\n      },\n      missingMembers,\n      refresh: this.fetchMeta,\n      isFetchingMeta,\n      dryRunResponse,\n      ...queryRendererProps,\n    };\n  }\n\n  updateQuery(queryUpdate) {\n    const { query } = this.state;\n\n    this.updateVizState({\n      query: removeEmptyQueryFields({\n        ...query,\n        ...queryUpdate,\n      }),\n    });\n  }\n\n  async updateVizState(state) {\n    const { setQuery, setVizState } = this.props;\n    const { query: stateQuery, pivotConfig: statePivotConfig, chartType, meta } = this.state;\n\n    const finalState = this.applyStateChangeHeuristics(state);\n    if (!finalState.query) {\n      finalState.query = { ...stateQuery };\n    }\n\n    let vizStateSent = null;\n    const handleVizStateChange = (currentState) => {\n      const { onVizStateChanged } = this.props;\n      if (onVizStateChanged) {\n        const newVizState = pick(['chartType', 'pivotConfig', 'query'], currentState);\n        // Don't run callbacks more than once unless the viz state has changed since last time\n        if (!vizStateSent || !equals(vizStateSent, newVizState)) {\n          onVizStateChanged(newVizState);\n          // use clone to make sure we don't save object references\n          vizStateSent = clone(newVizState);\n        }\n      }\n    };\n\n    // deprecated, setters replaced by onVizStateChanged\n    const runSetters = (currentState) => {\n      if (setVizState) {\n        setVizState(pick(['chartType', 'pivotConfig', 'query'], currentState));\n      }\n      if (currentState.query && setQuery) {\n        setQuery(currentState.query);\n      }\n    };\n\n    if (finalState.shouldApplyHeuristicOrder) {\n      finalState.query.order = defaultOrder(finalState.query);\n    }\n\n    finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(\n      finalState.query,\n      finalState.pivotConfig !== undefined ? finalState.pivotConfig : statePivotConfig\n    );\n\n    finalState.missingMembers = this.getMissingMembers(finalState.query, meta);\n    finalState.chartType = finalState.chartType || state.chartType || chartType;\n\n    // deprecated\n    runSetters({\n      ...state,\n      query: finalState.query,\n    });\n\n    // Update optimistically so that UI does not stutter\n    this.setState({\n      ...finalState,\n      queryError: null,\n    });\n\n    handleVizStateChange(finalState);\n\n    const shouldFetchDryRun = !equals(\n      pick(['measures', 'dimensions', 'timeDimensions'], stateQuery),\n      pick(['measures', 'dimensions', 'timeDimensions'], finalState.query)\n    );\n\n    if (shouldFetchDryRun && isQueryPresent(finalState.query) && finalState.missingMembers.length === 0) {\n      try {\n        const response = await this.cubeApi().dryRun(finalState.query, {\n          mutexObj: this.mutexObj,\n        });\n\n        if (finalState.shouldApplyHeuristicOrder) {\n          finalState.query.order = (response.queryOrder || []).reduce((memo, current) => ({ ...memo, ...current }), {});\n        }\n\n        finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(response.pivotQuery, finalState.pivotConfig);\n        finalState.validatedQuery = this.validatedQuery(finalState);\n        finalState.dryRunResponse = response;\n\n        // deprecated\n        if (isQueryPresent(stateQuery)) {\n          runSetters({\n            ...this.state,\n            ...finalState,\n          });\n        }\n      } catch (error) {\n        this.setState({\n          queryError: new Error(error.response?.plainError || error.message),\n          richQueryError: new Error(error.message || error.toString())\n        });\n      }\n    }\n\n    this.setState(finalState, () => handleVizStateChange(this.state));\n  }\n\n  validatedQuery(state) {\n    const { query } = state || this.state;\n\n    return validateQuery(query);\n  }\n\n  defaultHeuristics(newState) {\n    const { query, sessionGranularity, meta } = this.state;\n\n    return defaultHeuristics(newState, query, {\n      meta,\n      sessionGranularity: sessionGranularity || 'day',\n    });\n  }\n\n  applyStateChangeHeuristics(newState) {\n    const { stateChangeHeuristics, disableHeuristics } = this.props;\n    if (disableHeuristics) {\n      return newState;\n    }\n    return (stateChangeHeuristics && stateChangeHeuristics(this.state, newState)) || this.defaultHeuristics(newState);\n  }\n\n  render() {\n    const { query } = this.state;\n    const { cubeApi, render, wrapWithQueryRenderer } = this.props;\n\n    if (wrapWithQueryRenderer) {\n      return (\n        <QueryRenderer\n          query={query}\n          cubeApi={cubeApi}\n          resetResultSetOnChange={false}\n          render={(queryRendererProps) => {\n            if (render) {\n              return render(this.prepareRenderProps(queryRendererProps));\n            }\n            return null;\n          }}\n        />\n      );\n    } else {\n      if (render) {\n        return render(this.prepareRenderProps());\n      }\n      return null;\n    }\n  }\n}\n", "import React from 'react';\nimport CubeContext from './CubeContext';\n\nexport default function CubeProvider({ cubeApi, children, options = {} }) {\n  return (\n    <CubeContext.Provider value={{\n      cubeApi,\n      options\n    }}\n    >\n      {children}\n    </CubeContext.Provider>\n  );\n}\n", "import { useRef } from 'react';\nimport { equals } from 'ramda';\n\nexport default function useDeepCompareMemoize(value) {\n  const ref = useRef([]);\n\n  if (!equals(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n", "import { useEffect, useRef } from 'react';\n\nexport function useIsMounted() {\n  const isMounted = useRef(false);\n\n  useEffect(() => {\n    isMounted.current = true;\n\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return () => isMounted.current;\n}\n", "import { useContext, useEffect, useState, useRef } from 'react';\nimport { isQueryPresent } from '@cubejs-client/core';\n\nimport CubeContext from '../CubeContext';\nimport useDeepCompareMemoize from './deep-compare-memoize';\nimport { useIsMounted } from './is-mounted';\n\nexport function useCubeFetch(method, options = {}) {\n  const isMounted = useIsMounted();\n  const context = useContext(CubeContext);\n  const mutexRef = useRef({});\n\n  const [response, setResponse] = useState({\n    isLoading: false,\n    response: null,\n  });\n  const [error, setError] = useState(null);\n\n  const { skip = false } = options;\n\n  async function load(loadOptions = {}, ignoreSkip = false) {\n    const cubeApi = options.cubeApi || context?.cubeApi;\n    const query = loadOptions.query || options.query;\n\n    const queryCondition = method === 'meta' ? true : query && isQueryPresent(query);\n\n    if (cubeApi && (ignoreSkip || !skip) && queryCondition) {\n      setError(null);\n      setResponse({\n        isLoading: true,\n        response: null,\n      });\n\n      const coreOptions = {\n        mutexObj: mutexRef.current,\n        mutexKey: method,\n      };\n      const args = method === 'meta' ? [coreOptions] : [query, coreOptions];\n\n      try {\n        const response = await cubeApi[method](...args);\n\n        if (isMounted()) {\n          setResponse({\n            response,\n            isLoading: false,\n          });\n        }\n      } catch (error) {\n        if (isMounted()) {\n          setError(error);\n          setResponse({\n            isLoading: false,\n            response: null,\n          });\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    load();\n  }, useDeepCompareMemoize([Object.keys(options.query?.order || {}), options, context]));\n\n  return {\n    ...response,\n    error,\n    refetch: (options) => load(options, true),\n  };\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useCubeSql(query, options = {}) {\n  return useCubeFetch('sql', {\n    ...options,\n    query\n  });\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useDryRun(query, options = {}) {\n  return useCubeFetch('dryRun', {\n    ...options,\n    query,\n  });\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useLazyDryRun(query, options = {}) {\n  const { refetch, ...result } = useCubeFetch('dryRun', {\n    ...options,\n    query,\n    skip: true\n  });\n\n  return [refetch, result];\n}\n", "import { useContext, useEffect, useState, useRef } from 'react';\nimport { isQueryPresent, areQueriesEqual } from '@cubejs-client/core';\n\nimport CubeContext from '../CubeContext';\nimport useDeepCompareMemoize from './deep-compare-memoize';\nimport { useIsMounted } from './is-mounted';\n\nexport function useCubeQuery(query, options = {}) {\n  const mutexRef = useRef({});\n  const isMounted = useIsMounted();\n  const [currentQuery, setCurrentQuery] = useState(null);\n  const [isLoading, setLoading] = useState(!options.skip);\n  const [resultSet, setResultSet] = useState(null);\n  const [progress, setProgress] = useState(null);\n  const [error, setError] = useState(null);\n  const context = useContext(CubeContext);\n\n  let subscribeRequest = null;\n\n  const progressCallback = ({ progressResponse }) => setProgress(progressResponse);\n\n  async function fetch() {\n    const { resetResultSetOnChange } = options;\n    const cubeApi = options.cubeApi || context?.cubeApi;\n\n    if (!cubeApi) {\n      throw new Error('Cube API client is not provided');\n    }\n\n    if (resetResultSetOnChange) {\n      setResultSet(null);\n    }\n\n    setError(null);\n    setLoading(true);\n\n    try {\n      const response = await cubeApi.load(query, {\n        mutexObj: mutexRef.current,\n        mutexKey: 'query',\n        progressCallback,\n        castNumerics: Boolean(typeof options.castNumerics === 'boolean' ? options.castNumerics : context?.options?.castNumerics)\n      });\n\n      if (isMounted()) {\n        setResultSet(response);\n        setProgress(null);\n      }\n    } catch (error) {\n      if (isMounted()) {\n        setError(error);\n        setResultSet(null);\n        setProgress(null);\n      }\n    }\n\n    if (isMounted()) {\n      setLoading(false);\n    }\n  }\n\n  useEffect(() => {\n    const { skip = false, resetResultSetOnChange } = options;\n\n    const cubeApi = options.cubeApi || context?.cubeApi;\n\n    if (!cubeApi) {\n      throw new Error('Cube API client is not provided');\n    }\n\n    async function loadQuery() {\n      if (!skip && isQueryPresent(query)) {\n        if (!areQueriesEqual(currentQuery, query)) {\n          if (resetResultSetOnChange == null || resetResultSetOnChange) {\n            setResultSet(null);\n          }\n          setCurrentQuery(query);\n        }\n\n        setError(null);\n        setLoading(true);\n\n        try {\n          if (subscribeRequest) {\n            await subscribeRequest.unsubscribe();\n            subscribeRequest = null;\n          }\n\n          if (options.subscribe) {\n            subscribeRequest = cubeApi.subscribe(\n              query,\n              {\n                mutexObj: mutexRef.current,\n                mutexKey: 'query',\n                progressCallback,\n              },\n              (e, result) => {\n                if (isMounted()) {\n                  if (e) {\n                    setError(e);\n                  } else {\n                    setResultSet(result);\n                  }\n                  setLoading(false);\n                  setProgress(null);\n                }\n              }\n            );\n          } else {\n            await fetch();\n          }\n        } catch (e) {\n          if (isMounted()) {\n            setError(e);\n            setResultSet(null);\n            setLoading(false);\n            setProgress(null);\n          }\n        }\n      }\n    }\n\n    loadQuery();\n\n    return () => {\n      if (subscribeRequest) {\n        subscribeRequest.unsubscribe();\n        subscribeRequest = null;\n      }\n    };\n  }, useDeepCompareMemoize([query, Object.keys((query && query.order) || {}), options, context]));\n\n  return {\n    isLoading,\n    resultSet,\n    error,\n    progress,\n    previousQuery: currentQuery,\n    refetch: fetch\n  };\n}\n", "import { useCubeFetch } from './cube-fetch';\n\nexport function useCubeMeta(options = {}) {\n  return useCubeFetch('meta', options);\n}\n"],
  "mappings": "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",
  "names": ["createContext", "QueryRenderer", "React", "Component", "isQueryPresent", "query", "constructor", "props", "state", "mutexObj", "componentDidMount", "queries", "load", "loadQueries", "shouldComponentUpdate", "nextProps", "nextState", "render", "cubeApi", "loadSql", "updateOnlyOnStateChange", "equals", "componentDidUpdate", "prevProps", "context", "resetResultSetOnChange", "setState", "isLoading", "error", "sqlQuery", "resultSet", "sql", "mutexKey", "then", "catch", "Promise", "all", "resultPromises", "toPairs", "map", "name", "r", "fromPairs", "loadState", "Error", "response", "plainError", "message", "toString", "loadingState", "contextType", "CubeContext", "defaultProps", "QueryRendererWithTotals", "restProps", "createElement", "_extends", "totals", "dimensions", "timeDimensions", "td", "granularity", "undefined", "main", "removeEmpty", "obj", "Array", "isArray", "Object", "fromEntries", "entries", "filter", "v", "k", "granularities", "title", "QueryBuilder", "fetchMeta", "meta", "metaError", "richMetaError", "metaErrorStack", "isFetchingMeta", "stack", "replace", "updateQuery", "defaultQuery", "chartType", "defaultChartType", "validatedQuery", "missingMembers", "dryRunResponse", "vizState", "initialVizState", "orderMembersOrderKeys", "getDerivedStateFromProps", "resolveMember", "type", "reduce", "memo", "currentQuery", "concat", "m", "index", "dimension", "prevContext", "schemaVersion", "onSchemaChange", "newMeta", "refresh", "getMissingMembers", "getQueryMembers", "member", "resolvedMember", "Boolean", "prepareRenderProps", "queryRendererProps", "getName", "toTimeDimension", "rangeSelection", "compareDateRange", "dateRange", "toFilter", "operator", "includes", "values", "updateMethods", "memberType", "toQuery", "add", "remove", "_", "update", "updateWith", "members", "splice", "queryError", "pivotConfig", "flatFilters", "uniqBy", "prop", "flattenFilters", "filters", "i", "operators", "filterOperatorsForMember", "measures", "segments", "availableMeasures", "availableDimensions", "availableSegments", "availableFilterMembers", "availableMembers", "membersGroupedByCube", "membersForQuery", "indexedMeasures", "indexBy", "indexedDimensions", "cubeNames", "uniq", "keys", "sort", "cube", "a", "b", "shortTitle", "activeOrder", "order", "orderMembers", "id", "length", "find", "availableTimeDimensions", "queryUpdate", "updateMeasures", "updateDimensions", "updateSegments", "updateTimeDimensions", "updateFilters", "updateChartType", "newChartType", "updateVizState", "updateOrder", "set", "memberId", "newOrder", "orderMember", "acc", "reorder", "sourceIndex", "destinationIndex", "nextArray", "moveItemInArray", "updatePivotConfig", "moveItem", "sourceAxis", "destinationAxis", "movePivotItem", "config", "limit", "removeEmptyQueryFields", "setQuery", "setVizState", "stateQuery", "statePivotConfig", "finalState", "applyStateChangeHeuristics", "vizStateSent", "handleVizStateChange", "currentState", "onVizStateChanged", "newVizState", "pick", "clone", "runSetters", "shouldApplyHeuristicOrder", "defaultOrder", "ResultSet", "getNormalizedPivotConfig", "shouldFetchDryRun", "dryRun", "queryOrder", "current", "pivotQuery", "richQueryError", "validateQuery", "defaultHeuristics", "newState", "sessionGranularity", "stateChangeHeuristics", "disableHeuristics", "wrapWithQueryRenderer", "CubeProvider", "children", "options", "Provider", "value", "useDeepCompareMemoize", "ref", "useRef", "useIsMounted", "isMounted", "useEffect", "useCubeFetch", "method", "useContext", "mutexRef", "setResponse", "useState", "setError", "skip", "loadOptions", "ignoreSkip", "queryCondition", "coreOptions", "args", "refetch", "useCubeSql", "useDryRun", "useLazyDryRun", "result", "useCubeQuery", "setCurrentQuery", "setLoading", "setResultSet", "progress", "setProgress", "subscribeRequest", "progressCallback", "progressResponse", "fetch", "castNumerics", "loadQuery", "areQueriesEqual", "unsubscribe", "subscribe", "e", "previousQuery", "useCubeMeta"]
}
